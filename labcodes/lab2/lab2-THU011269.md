#Lab2实验报告

##练习1:实现 first-fit 连续物理内存分配算法

要求修改default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，逐个分析：
init：负责循环链表的初始化，就是计数器清零，和简单的初始化，相比于原来不需要修改；
init_memmap: 分配一段空内存。从这部分可以看出修改后的代码和原来的代码的不同：原来的代码列表中只保存空闲快的头，而新列表中则是保存每个空闲块的头。针对这一点，这个函数和下面的两个函数都有相应的变化。
allocate：这部分我主要是保留了原有的代码，所以和答案的差距最大。不过细节是很像的，找到一块足够大的就分配，FirstFit，其实原来就是FirstFit的方法，只不过上面说过了，原有的代码不是页表机制。
free： 释放主要是收尾的时候需要合并空闲快，而现在变成了在链表中加入新的表项（空闲快），并且修改对应的property。

##练习2：实现寻找虚拟地址对应的页表项
##练习3：释放某虚地址所在的页并取消对应二级页表项的映射
练习2/3很像，都是对二级页表的处理，一个get一个remove。get只需按照一级二级页表的定义，调用对应的转换函数，就可以得到二级页表项；remove则是结合ref释放表项和page。

##练习思考题
1. 你的first fit算法是否有进一步的改进空间

暂无。

2.1. 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。
一个页表项和一个页目录表项大小为32位。每位功能可从mmu.h中获取，后12位是控制位，前20位是基地址。
具体每一位功能：（参考其他来源）
第一位是存在位，表明该表项对应的页是否存在；
第二位代表页内容是否可写；
第三页代表用户态的软件是否能读取页的内容；
第四位代表是否为写直达；
第五位代表映射的页面有没有被装入缓存，可以帮助实现快表；
第六位代表映射的页面是否在被访问；
第七位代表该页是否被修改过，可以帮助实现虚拟存储中页面在外存和内存中的移动问题；
第八位和第九位必须被置零；
第10、11、12位是留给软件使用的，可以留给软件拓展自己功能的余地。
剩下的20位便是代表被映射的页面的基地址，以配合线性地址中的偏移量实现对应内存的定位。

2.2. 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
保存现场：CR2寄存器保存异常地址，出错码异常类型；相关参数入栈，异常中断号>CS 中断服务地址>EIP，操作系统执行中断服务例程，结束后恢复现场。

3.1. 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
有关系，page的索引即页表项的基地址（前20位）。
3.2. 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 
修改gdt_init使虚拟地址映射到相等的物理地址。

##参考答案分析：
本次试验参考答案没有报告，所以主要是代码：
第一题我比较熟悉一些，很多部分都是自己写的，有些部分和代码不太一样导致一些check错误，所以又很少一部分是参考答案的。
第二三题确实不是很熟，不过也很短，所以参考了答案，不过基本弄懂了，而且感觉也没什么可以改的部分。

##知识点分析
- 1. 段页式内存分配
- 2. 页表相关，一级页表二级页表

未涉及：
- 1. 连续内存分配（因为代码里直接用了页表）
- 2. 伙伴系统
